#pragma once

#include <windef.h>
#include <iosfwd>
using namespace std;

namespace BerTLV {
	/* Класс токена одного BER-TLV тега */
	class BerTLVDecoderToken {
	private:
		/* Классы тега */
		enum class BerTagClass { UNIVERSAL, APPLICATION, CONTEXT_SPECIFIC, PRIVATE };

		/* Тип тега */
		enum class BerTagType { PRIMITIVE, CONSTRUCTED };

		/* Пару typedef'ов, чтобы было удобней */
		typedef tuple<BerTagClass, BerTagType, UINT64> BerTagTuple;
		typedef tuple<UINT32, UINT32> BerLenTuple;

		/* Тег токена */
		UINT64 berTag;

		/* Длина тега */
		UINT32 berLen;
		
		/* Смещение данных тега внутри потока */
		UINT32 berDataStart;

		/* Класс тега */
		BerTagClass berTagClass;

		/* Тип тега */
		BerTagType berTagType;

		/* Индекс родителя тега */
		UINT16 berParentIndex;

		/* Функция получения тега */
		BerTagTuple decodeTag(istream& stream) {
			/* Сначала получаем байт тега */
			UINT8 firstByte = stream.get();

			/* Определяем класс и тип тега */
			BerTagClass berTagClassRaw = (BerTagClass)((firstByte >> 6) & 0x03);
			BerTagType berTagTypeRaw = (BerTagType)((firstByte >> 5) & 0x01);

			/* Получаем сам номер тега */
			UINT64 berTagRaw = firstByte;

			/* Если 5 бит тега не равны единицам - то это единственный тег */
			if ((firstByte & 0x1F) == 0x1F) {
				/* Иначе, надо получить полный номер тега */
				for (UINT i = 0; i < 8; i += 1) {
					/* Получаем очередной байт тега */
					UINT8 tagNum = stream.get();

					/* Записываем его в итоговое число тега */
					berTagRaw = (berTagRaw << 8) | tagNum;

					/* Смотрим, установлен ли старший бит, если нет - это конец номера тега */
					if (((tagNum >> 7) & 0x01) == 0) { i = 8; }
				}
			}

			/* Агрегируем данные в неизменяемый многотиповой массив - tuple */
			return make_tuple(berTagClassRaw, berTagTypeRaw, berTagRaw);
		}

		/* Функция получения  */
		BerLenTuple decodeLength(istream& stream) {
			/* Считываем первый байт длины */
			UINT8 firstByte = stream.get();

			/* Если в первом байте длины установлен старший бит */
			/* То длина продолжается в других байтах */
			/* Кол - во равно первому байту(без старшего бита) */
			UINT64 berLenRaw = firstByte;
			if ((firstByte & 0x80) == 0x80) {
				/* Получаем кол-во байтов длины */
				UINT8 lenBytes = (firstByte & 0x7F);

				/* Пусть максимально можно будет задать 4 байта длиной */
				if (lenBytes >= sizeof(berLen)) {
					throw std::exception("Ошибка: длина данных больше, чем тип, способный её уместить");
				}

				/* Добавляем эти байты, пока не дошли до нуля */
				berLenRaw = 0;
				for (UINT8 i = 0; i < lenBytes; i += 1) {
					berLenRaw = (berLenRaw << 8) | (UINT8)stream.get();
				}
			}

			/* Агрегируем начало длину данных тега */
			return make_tuple(stream.tellg(), berLenRaw);
		}

	public:
		BerTLVDecoderToken() = default;

		BerTLVDecoderToken(istream& stream, UINT16 parentIdx) {
			/* Декодируем тег */
			BerTagTuple tagTuple = decodeTag(stream);

			/* Декодируем длину данных */
			BerLenTuple lenTuple = decodeLength(stream);

			/* Присваиваем всю информацию */
			berTagClass = get<0>(tagTuple);
			berTagType = get<1>(tagTuple);
			berTag = get<2>(tagTuple);

			berDataStart = get<0>(lenTuple);
			berLen = get<1>(lenTuple);

			berParentIndex = parentIdx;

			/* Если это не составной тег, то его данные можно пропустить */
			if (berTagType == BerTagType::PRIMITIVE) {
				stream.seekg(berLen, ios::cur);
			}
		}

		/* Проверка на то, что тег составной */
		bool isConstructed() { return berTagType == BerTagType::CONSTRUCTED; };

		/* Получить тег */
		UINT64 getTag() { return berTag; }

		/* Получить начало данных */
		UINT32 getDataStart() { return berDataStart; }

		/* Получить длину данных */
		UINT32 getDataLen() { return berLen; }

		/* Получить родителя тега */
		UINT16 getParent() { return berParentIndex; }

		/* Функция для получения данных тега */
		unique_ptr<UINT8> getData(istream& stream) {
			stream.seekg(berDataStart);

			unique_ptr<UINT8> data(new UINT8[berLen]);
			stream.read((char*)data.get(), berLen);
			return data;
		}

		/* В теории, можно сделать класс декодера дружественным этому */
		/* Чтобы избежать лишних функций */
	};

	/* Класс декодировщика BER-TLV данных */
	class BerTLVDecoder {
	private:
		/* Функция декодирования, которая вызывается типа рекурсивно */
		UINT16 decode(istream& stream, UINT16 parentIndex, UINT32 parentTokenEnd) {
			/* Получив конец данных, функция знает, когда стоит остановиться */
			while (stream.tellg() < parentTokenEnd) {
				/* Создать новый токен */
				BerTLVDecoderToken token(stream, parentIndex);

				/* Добавить в массив токенов */
				tokens[tokenSize++] = token;

				/* Проверить, не закончилось ли место для токенов */
				checkForExtend();

				/* Если токен составной */
				if (token.isConstructed()) {
					/* Начать декодировать токены, определив */
					/* Новый конец и индекс родителя равный индеску текущего токена */
					decode(stream, tokenSize - 1, token.getDataLen() + stream.tellg());
				}
			}

			/* Вернуть ноль в головную функцию - это указывает на начало массива токенов */
			return 0;
		}

		/* Функция проверки оставшегося места в массиве токенов */
		void checkForExtend() {
			/* Если размер токенов не превышает максимального размера */
			if (tokenSize < tokenMaxSize) {
				/* То делать ничего не надо */
				return;
			}
			
			/* Иначе вдвое расширим максимальную вместимость */
			tokenMaxSize *= 2;

			/* Выделим кусок памяти с новой вместимостью */
			auto newPiece = make_unique<BerTLVDecoderToken[]>(tokenMaxSize);

			/* Скопируем старый кусок памяти в новый */
			memcpy(newPiece.get(), tokens.get(), tokenSize * sizeof(BerTLVDecoderToken));

			/* Освободим старую память */
			tokens.release();

			/* Обменяем указатели - теперь newPiece = nullptr */
			/* А tokens - хранит в себе новый массив токенов */
			tokens.swap(newPiece);
		}
	public:
		/* Максимальный размер массива токенов */
		UINT16 tokenMaxSize = 8;

		/* Текущий размер массива токенов */
		UINT16 tokenSize = 0;

		/* Сам массив токенов */
		unique_ptr<BerTLVDecoderToken[]> tokens;

		/* Конструктор декодера */
		BerTLVDecoder() : tokens(new BerTLVDecoderToken[tokenMaxSize]) {}

		/* Функция декодирования */
		UINT16 decode(istream& stream) {
			/* Получаем размер потока данных */
			stream.seekg(0, ios::end);
			UINT32 streamLen = stream.tellg();
			stream.seekg(0);

			/* Обнуляем текущий размер токенов */
			tokenSize = 0;
			return decode(stream, 0, streamLen);
		}

		/* Способ получить индекс токена по его тегу внутри составного тега */
		UINT16 getChildByTag(UINT16 parent, UINT64 childTag) {
			/* Начинаем с первого тега под родителем (так как в массиве они находятся подряд) */
			for (UINT16 i = parent + 1; i < tokenSize; i += 1) {
				/* Получаем токен по индексу */
				BerTLVDecoderToken* token = &tokens[i];

				/* И проверяем его соответствие */
				if (token->getTag() == childTag && token->getParent() == parent) {
					/* Возвращаем индекс этого токена, если это тот, что нужен */
					return i;
				}
			}
			
			/* Иначе, если не найден токен, вернуть ноль */
			return 0;
		}

		/* Получение самого токена (его указателя, если вернее) */
		BerTLVDecoderToken* getTokenPtr(UINT16 tokenIndex) {
			/* Если каким-то образом индекс больше текущего размера массива */
			if (tokenIndex > tokenSize) {
				/* То вернуть нулевой указатель */
				return nullptr;
			}

			/* Во всех остальных случаях, вернуть адрес токена по индексу */
			return &tokens[tokenIndex];
		}
	};

	/* TODO: сделать BER-TLV кодировщик, как - пока не придумал */
}